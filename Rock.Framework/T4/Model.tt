<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ Assembly name="System.Data" #>
<#@ Assembly name="System.Xml" #>
<#@ Assembly name="Microsoft.SqlServer.SqlEnum" #>
<#@ Assembly name="Microsoft.SqlServer.ConnectionInfo" #>
<#@ Assembly name="Microsoft.SqlServer.Smo" #>
<#@ Assembly name="Microsoft.SqlServer.Management.Sdk.Sfc" #>

<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.SqlServer.Management.Common" #>
<#@ import namespace="Microsoft.SqlServer.Management.Smo" #>
 
<#
	// Uncomment this line to debug the template generation
	//System.Diagnostics.Debugger.Launch();
	
	// Database properties
	//string connectionString = @"Data Source=172.16.0.7; User Id=RockUser; password=dw72Y13a7Qgm";
    string connectionString = @"Data Source=24.249.179.215; User Id=RockUser; password=dw72Y13a7Qgm";
	//string connectionString = @"Server=LocalHost;Trusted_Connection=True;";
    string databaseName = "RockChMS";
	
	// Connect to database and create the Server and Database objects
	SqlConnection oneSqlConnection = new SqlConnection(connectionString);
    ServerConnection oneServerConnection = new ServerConnection(oneSqlConnection);
    Server oneServer = new Server(oneServerConnection);
    Database oneDatabase = oneServer.Databases[databaseName];
	
	string relativeOutputFilePath = "";
	
	// When looping through the tables, keep track of the model entities created
	// and the namespaces used so that they can be used when creating the context 
	// class
	Dictionary<string, string> entities = new Dictionary<string, string>();
	List<string> namespaces = new List<string>();
	List<string> processedM2MTables = new List<string>();
	
	// Loop through each non-system table in the database
	foreach (Table oneTable in oneDatabase.Tables)
	{
		string Namespace = TemplateHelper.Namespace(oneTable.Name);
		string Entity = TemplateHelper.Entity(oneTable.Name);
		string QualifiedEntity = "Rock.Models." + Namespace + "." + Entity;

		if (!oneTable.IsSystemObject && !TemplateHelper.Many2Many(oneTable))
		{
			// Save list of primary keys so that the get[Entity] method in the 
			// service layer class can be created correctly
			List<Column> primaryKeys = new List<Column>();
			
			// Save namespace from the table name.
			if (!namespaces.Contains(Namespace))
				namespaces.Add(Namespace);
			
			// Save entity name from the table name
			entities.Add(QualifiedEntity, Entity);
			
			// If namespace exists, create generated files in a subfolder
			string projectSubFolder = Namespace != "" ? Namespace + @"\" : "";
			
			// Text for appending namespace to project namespace
			string projectNamespace = Namespace != "" ? "." + Namespace : "";

			string baseClass = "ModelWithAttributes";
			if (Entity == "Attribute" ||
				Entity == "AttributeQualifier" ||
				Entity == "AttributeValue" ||
				Entity == "FieldType")
				baseClass = "Model";
			
			// Read any existing partial class to find property attributes that have been defined in a comment class
			string partialFilePath = @"..\..\Models\" + projectSubFolder + Entity + ".Partial.cs";
			Dictionary<int, string> partialClassLines = TemplateHelper.readTextFile(Host, partialFilePath);
			
			// Redirect the template output to a stringbuilder object rather than being automatically
			// written to a cs file.  This is so output files can be created manually
		    GenerationEnvironment = new System.Text.StringBuilder();
			
			Column created = oneTable.Columns["CreatedDateTime"];
			Column modified = oneTable.Columns["ModifiedDateTime"];
			Column createdById = oneTable.Columns["CreatedByPersonId"];
			Column modifiedById = oneTable.Columns["ModifiedByPersonId"];
			
			string iAuditable = "";
			if (created != null && created.Nullable && created.DataType.ToString() == "datetime" &&
				modified != null && modified.Nullable && modified.DataType.ToString() == "datetime" &&
				createdById != null && createdById.Nullable && createdById.DataType.ToString() == "int" &&
				modifiedById != null && modifiedById.Nullable && modifiedById.DataType.ToString() == "int")
				iAuditable = ", IAuditable";

			Column orderCol = oneTable.Columns["Order"];
			string iOrdered = "";
			if (orderCol != null && !orderCol.Nullable && orderCol.DataType.ToString() == "int")
				iOrdered = ", IOrdered";
			
// Generate POCO model
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Data.Entity.ModelConfiguration;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;

using Rock.Models;

namespace Rock.Models<#= projectNamespace #>
{
    [Table( "<#= oneTable.Name #>" )]
    public partial class <#= Entity #> : <#= baseClass #><#= iAuditable #><#= iOrdered #>
    {
<#
			// Write the properties for each column in the table
			foreach(Column column in oneTable.Columns)
			{
				// Add the [Key] attribute for all primary key columns
				if (column.InPrimaryKey)
				{
					primaryKeys.Add(column);
					
					if (column.Name != "Id")
					{
#>
		[Key]
<#
					}
				}
				
				if (column.Name != "Id")
				{
					// If the column is a varchar with a specific length, add the [MaxLength]
					// validation attribute
					if ((column.DataType.ToString() == "varchar" || column.DataType.ToString() == "nvarchar") && column.DataType.MaximumLength > 0)
					{
#>
		[MaxLength( <#= column.DataType.MaximumLength.ToString() #> )]
<#
					}

					string dataMember = "[DataMember]";
					string property = "";
					
					if (column.DataType.ToString() == "int")
					{
						// Check for enumeration in the description property in the format enum[NameOfEnum]
						ExtendedProperty descProperty = column.ExtendedProperties["MS_Description"];
						
						if (descProperty != null)
						{
							string colDesc = descProperty.Value.ToString();
							int iStart = colDesc.ToLower().IndexOf("enum[");
							if (iStart > 0)
							{
								iStart += 5;
								int iEnd = colDesc.IndexOf("]", iStart);
								if (iEnd > iStart)
								{
									string enumName = colDesc.Substring(iStart, iEnd - iStart);
									
									dataMember = "[DataMember(Name = \"" + column.Name + "\")]";
									
									property = 
									"internal " + TemplateHelper.ConvertDataType(column) + " " + column.Name + "Internal { get; set; }\n\n" +
									"\t\t[NotMapped]\n" +
									"\t\tpublic " + enumName + " " + column.Name + "\n" +
									"\t\t{\n" +
									"\t\t\tget { return (" + enumName + ")this." + column.Name + "Internal; }\n" +
									"\t\t\tset { this." + column.Name + "Internal = (int)value; }\n" + 
									"\t\t}";

								}
							}
						}						
					}
						
					if (property == "")
						property = "public " + TemplateHelper.ConvertDataType(column) + " " + column.Name + " { get; set; }";
						
					List<string> attributes = TemplateHelper.getAttributes(partialClassLines, property);
					foreach(string attribute in attributes)
					{
#>
		<#= attribute #>
<#
					}
#>
		<#= dataMember #>
		<#= property #>
		
<#
				}
			}
#>
		[NotMapped]
		public override string AuthEntity { get { return "<#= Namespace #>.<#= Entity #>"; } }
<#
			// Keep track of any foreign key relationship that a table has to itself, and any 
			// many-to-many relationship. These need to be defined explicitely in the model's 
			// Configuration class
			List<string> specialReferences  = new List<string>();
			
			// Process any related child table relationships 
			System.Data.DataTable dt = oneTable.EnumForeignKeys();
			foreach(System.Data.DataRow row in dt.Rows)
			{
				string relatedTableName = row["Table_Name"].ToString();
				string relatedEntity = TemplateHelper.Entity(relatedTableName);		
				string relatedNamespace = TemplateHelper.Namespace(relatedTableName);
				string fkName = row["Name"].ToString();
				string propertyName = relatedEntity;
				
				if (!fkName.ToLower().Contains("nomodel"))
				{
					Table relatedTable = oneDatabase.Tables[relatedTableName];
					if (TemplateHelper.Many2Many(relatedTable))
					{
						ForeignKey parentForeignKey = relatedTable.ForeignKeys[fkName];
						string parentKeyColumn = parentForeignKey.Columns[0].Name;
						string parentPropertyName = "";
						if (parentKeyColumn.EndsWith( "Guid" ))
							parentPropertyName = parentKeyColumn.Substring( 0, parentKeyColumn.Length - 4 );
						else
							parentPropertyName = parentKeyColumn.Substring( 0, parentKeyColumn.Length - 2 );
						
						foreach(ForeignKey childForeignKey in relatedTable.ForeignKeys)
							if (childForeignKey.Name != fkName)
							{
								Table childTable = oneDatabase.Tables[childForeignKey.ReferencedTable];							
								relatedEntity = TemplateHelper.Entity(childTable.Name);
								relatedNamespace = TemplateHelper.Namespace(childTable.Name);
								string childKeyColumn = childForeignKey.Columns[0].Name;
								if (childKeyColumn.EndsWith( "Guid" ))
									propertyName = childKeyColumn.Substring( 0, childKeyColumn.Length - 4 );
								else
									propertyName = childKeyColumn.Substring( 0, childKeyColumn.Length - 2 );

								if (!processedM2MTables.Contains(relatedTable.Name))
								{
									specialReferences.Add(string.Format(
										"this.HasMany( p => p.{0}s ).WithMany( c => c.{1}s ).Map( m => {{ m.MapLeftKey(\"{2}\"); m.MapRightKey(\"{3}\"); m.ToTable(\"{4}\" ); }} );",
										propertyName,  parentPropertyName, 
										childKeyColumn, parentKeyColumn, 
										relatedTable.Name));
										
									processedM2MTables.Add(relatedTable.Name);
								}
							}
					}

					if (relatedNamespace == Namespace)
						relatedNamespace = "";
					else
						relatedNamespace += ".";
				
#>

		public virtual ICollection<<#= relatedNamespace #><#= relatedEntity #>> <#= propertyName #>s { get; set; }
<#	
				}
			}
			
			// Process foreign key relationships (Parent tables)
			foreach(ForeignKey foreignKey in oneTable.ForeignKeys)
			{
				string relatedEntity = TemplateHelper.Entity(foreignKey.ReferencedTable);
				
				string relatedNamespace = TemplateHelper.Namespace(foreignKey.ReferencedTable);
				if (relatedNamespace == Namespace)
					relatedNamespace = "";
				else
					relatedNamespace += ".";
				
				string propertyName = relatedEntity;
				
				if ( foreignKey.Columns.Count == 1 &&
					(foreignKey.Columns[0].Name.EndsWith( "Guid" ) || (foreignKey.Columns[0].Name.EndsWith( "Id" ))))
				{
					string colName = foreignKey.Columns[0].Name;

					// Strip the trailing 'Id' from the column name to use as the property name
					if (colName.EndsWith( "Guid" ))
						propertyName = colName.Substring( 0, colName.Length - 4 );
					else
						propertyName = colName.Substring( 0, colName.Length - 2 );
					
						string relationshipType = oneTable.Columns[colName].Nullable ? "Optional" : "Required";
						
						// Create the configuration text to be added in the model's configuration class
						if (foreignKey.Name.ToLower().Contains("nomodel"))
							specialReferences.Add(string.Format(
								"this.Has{0}( p => p.{1} ).WithMany().HasForeignKey( p => p.{2} );",
								relationshipType, propertyName, colName ));
						else
							specialReferences.Add(string.Format(
								"this.Has{0}( p => p.{1} ).WithMany( p => p.{2}s ).HasForeignKey( p => p.{3} );",
								relationshipType, propertyName, Entity, colName ));
				}
#>

		public virtual <#= relatedNamespace #><#= relatedEntity #> <#= propertyName #> { get; set; }
<#
			}
#>
    }

    public partial class <#= Entity #>Configuration : EntityTypeConfiguration<<#= Entity #>>
    {
        public <#= Entity #>Configuration()
        {
<#
			// If table has a composite primary key, a "HasKey" entry needs to be added to 
			// the models configuration class
			if (primaryKeys.Count > 1)
			{
				StringBuilder hasKeys = new StringBuilder();
				
				foreach(Column column in primaryKeys)
					hasKeys.AppendFormat("{0}k.{1}",
						hasKeys.Length > 0 ? ", " : "",
						column.Name);
#>
			this.HasKey( k => new { <#= hasKeys #> } );
<#
			}
			
			// If table has a one-to-many relationship with itself (heirarchal data) the relationship 
			// needs to be defined explicitly
			foreach(string specialReference in specialReferences)
			{
#>
			<#= specialReference #>
<#
			}
#>
		}
    }
}
<#
			// Write the POCO model
		    relativeOutputFilePath = @"..\..\Models\" + projectSubFolder + Entity + ".cs";
		    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);
			
		    GenerationEnvironment = new System.Text.StringBuilder();
			
// Generate Repository Interface
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;

using Rock.Models<#= projectNamespace #>;

namespace Rock.Repository<#= projectNamespace #>
{
    public interface I<#= Entity #>Repository : IRepository<<#= QualifiedEntity #>>
    {
    }
}
<#
			// Write the Repository Interface
		    relativeOutputFilePath = @"..\..\Repository\" + projectSubFolder + "I" + Entity + "Repository.cs";
		    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);
			
		    GenerationEnvironment = new System.Text.StringBuilder();
			
// Generate Repository Entity Framework Class
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Rock.Models<#= projectNamespace #>;

namespace Rock.Repository<#= projectNamespace #>
{
    public partial class Entity<#= Entity #>Repository : EntityRepository<<#= QualifiedEntity #>>, I<#= Entity #>Repository
    {
    }
}
<#
			// Write the Repository Entity Framework Class
		    relativeOutputFilePath = @"..\..\Repository\" + projectSubFolder + "Entity" + Entity + "Repository.cs";
		    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);
			
		    GenerationEnvironment = new System.Text.StringBuilder();
			
// Generate the Service Later Class
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Rock.Models<#= projectNamespace #>;
using Rock.Repository<#= projectNamespace #>;

namespace Rock.Services<#= projectNamespace #>
{
    public partial class <#= Entity #>Service : Rock.Services.Service
    {
        private I<#= Entity #>Repository _repository;

        public <#= Entity #>Service()
			: this( new Entity<#= Entity #>Repository() )
        { }

        public <#= Entity #>Service( I<#= Entity #>Repository <#= Entity #>Repository )
        {
            _repository = <#= Entity #>Repository;
        }

        public IQueryable<<#= QualifiedEntity #>> Queryable()
        {
            return _repository.AsQueryable();
        }

<#
			// Create the Get[Entity] method based on the table's (entity's) 
			// primary keys
			if (primaryKeys.Count > 0)
			{
				StringBuilder parameters = new StringBuilder();
				StringBuilder linqClause = new StringBuilder();
				
				foreach(Column column in primaryKeys)
				{
					parameters.AppendFormat("{0}{1} {2}{3}",
						parameters.Length > 0 ? ", " : "",
						TemplateHelper.ConvertDataType(column),
						column.Name.Substring(0,1).ToLower(),
						column.Name.Substring(1));
					
					linqClause.AppendFormat("{0}t.{1} == {2}{3}",
						linqClause.Length > 0 ? " && " : "",
						column.Name,
						column.Name.Substring(0,1).ToLower(),
						column.Name.Substring(1));
				}
#>
        public <#= QualifiedEntity #> Get<#= Entity #>( <#= parameters #> )
        {
            return _repository.FirstOrDefault( t => <#= linqClause #> );
        }
		
<#
			}

			foreach(Index index in oneTable.Indexes)
			{
				if (index.IndexKeyType != IndexKeyType.DriPrimaryKey)
				{
					string returnName = index.IsUnique ? Entity : Entity + "s";
					string returnType = index.IsUnique ? Entity : string.Format("IEnumerable<{0}>", QualifiedEntity);
					string queryType = index.IsUnique ? "FirstOrDefault" : "Find";
					StringBuilder getClause = new StringBuilder();
					StringBuilder parameters = new StringBuilder();
					StringBuilder linqClause = new StringBuilder();
					
					string orderByClause = string.Empty;
					if (iOrdered != "" && !index.IsUnique)
						orderByClause = ".OrderBy( t => t.Order )";
					
					foreach(IndexedColumn indexColumn in index.IndexedColumns)
					{
						Column column = oneTable.Columns[indexColumn.Name];

						getClause.AppendFormat("{0}{1}",
							getClause.Length > 0 ? "And" : "",
							column.Name);
						
						parameters.AppendFormat("{0}{1} {2}{3}",
							parameters.Length > 0 ? ", " : "",
							TemplateHelper.ConvertDataType(column),
							column.Name.Substring(0,1).ToLower(),
							column.Name.Substring(1));
						
						linqClause.AppendFormat("{0}{1}",
							linqClause.Length > 0 ? " && " : "",
							TemplateHelper.WhereClause(column));
					}
#>
        public <#= returnType #> Get<#= returnName #>By<#= getClause #>( <#= parameters #> )
        {
            return _repository.<#= queryType #>( t => <#= linqClause #> )<#= orderByClause #>;
        }
		
<#
				}
			}
#>
        public void Add<#= Entity #>( <#= QualifiedEntity #> <#= Entity #> )
        {
            if ( <#= Entity #>.Guid == Guid.Empty )
                <#= Entity #>.Guid = Guid.NewGuid();

            _repository.Add( <#= Entity #> );
        }

        public void Attach<#= Entity #>( <#= QualifiedEntity #> <#= Entity #> )
        {
            _repository.Attach( <#= Entity #> );
        }

		public void Delete<#= Entity #>( <#= QualifiedEntity #> <#= Entity #> )
        {
            _repository.Delete( <#= Entity #> );
        }

        public void Save( <#= QualifiedEntity #> <#= Entity #>, int? personId )
        {
            List<Rock.Models.Core.EntityChange> entityChanges = _repository.Save( <#= Entity #>, personId );
<#
			if (Entity != "EntityChange")
			{
#>

			if ( entityChanges != null )
            {
                Rock.Services.Core.EntityChangeService entityChangeService = new Rock.Services.Core.EntityChangeService();

                foreach ( Rock.Models.Core.EntityChange entityChange in entityChanges )
                {
<#
			if (primaryKeys.Count == 1)
			{
#>
                    entityChange.EntityId = <#= Entity #>.Id;
<#
			}
#>
                    entityChangeService.AddEntityChange ( entityChange );
                    entityChangeService.Save( entityChange, personId );
                }
            }
<#
			}
#>
        }
<#
			if (iOrdered != "")
			{
#>

        public void Reorder( List<<#= QualifiedEntity #>> <#= Entity #>s, int oldIndex, int newIndex, int? personId )
        {
            <#= QualifiedEntity #> moved<#= Entity #> = <#= Entity #>s[oldIndex];
            <#= Entity #>s.RemoveAt( oldIndex );
            if ( newIndex >= <#= Entity #>s.Count )
                <#= Entity #>s.Add( moved<#= Entity #> );
            else
                <#= Entity #>s.Insert( newIndex, moved<#= Entity #> );

            int order = 0;
            foreach ( <#= QualifiedEntity #> <#= Entity #> in <#= Entity #>s )
            {
                if ( <#= Entity #>.Order != order )
                {
                    <#= Entity #>.Order = order;
                    Save( <#= Entity #>, personId );
                }
                order++;
            }
        }
<#
			}
#>
    }
}
<#
			// Write the Service Layer Class
		    relativeOutputFilePath = @"..\..\Services\" + projectSubFolder + Entity + "Service.cs";
		    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);

			GenerationEnvironment = new System.Text.StringBuilder();
		}
	}
// Generate Repository Entity Framework Class
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Objects;
using System.Data.Entity;
using System.Linq;
using System.Web;

namespace Rock.EntityFramework
{
    public partial class RockContext : DbContext
    {
<#
		foreach ( KeyValuePair<string, string> entity in entities )
		{
#>
        public DbSet<<#= entity.Key #>> <#= entity.Value #>s { get; set; }
<#
		}
#>

        protected override void OnModelCreating( DbModelBuilder modelBuilder )
        {
<#
		foreach ( KeyValuePair<string, string> entity in entities )
		{
#>
            modelBuilder.Configurations.Add( new <#= entity.Key #>Configuration() );
<#
		}
#>
		}
    }
}

<#
	// Write the Entity Framework Context Class
    relativeOutputFilePath = @"..\..\EntityFramework\RockContext.cs";
    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);
	
    GenerationEnvironment = new System.Text.StringBuilder();
// Generate Rest Service Interface Class
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.Text;

namespace RockWeb.WCF
{
    // Rest Verbs...
    // GET = Retrieve
    // PUT = Update
    // POST = Create/Insert
    // DELETE = Delete

    [ServiceContract( Namespace = "", Name = "RestService" )]
    public interface IRestService
    {
<#
		foreach ( KeyValuePair<string, string> entity in entities )
		{
			string entityVar = entity.Value.Substring(0,1).ToLower() + entity.Value.Substring(1);
#>
		#region <#= entity.Value #>
		
		[OperationContract]
        [WebInvoke(Method = "GET", UriTemplate = "<#= entity.Value.ToLower() #>/{id}", ResponseFormat = WebMessageFormat.Json )]
        <#= entity.Key #> Get<#= entity.Value #>Json( string id );

        [OperationContract]
        [WebInvoke( Method = "GET", UriTemplate = "<#= entity.Value.ToLower() #>/{id}/xml", ResponseFormat = WebMessageFormat.Xml )]
        <#= entity.Key #> Get<#= entity.Value #>Xml( string id );
		
        [OperationContract]
        [WebInvoke( Method = "PUT", UriTemplate = "<#= entity.Value.ToLower() #>/{id}", ResponseFormat = WebMessageFormat.Json )]
        void Update<#= entity.Value #>( string id, <#= entity.Key #> <#= entityVar #> );

        [OperationContract]
        [WebInvoke( Method = "POST", UriTemplate = "<#= entity.Value.ToLower() #>", ResponseFormat = WebMessageFormat.Json )]
        void Create<#= entity.Value #>( <#= entity.Key #> <#= entityVar #> );

        [OperationContract]
        [WebInvoke( Method = "DELETE", UriTemplate = "<#= entity.Value.ToLower() #>/{id}", ResponseFormat = WebMessageFormat.Json )]
        void Delete<#= entity.Value #>( string id );

		#endregion
		
<#
		}
#>
    }
}
<#
	// Write the Rest Service Interface Class
    relativeOutputFilePath = @"..\..\..\RockWeb\App_Code\IRestService.cs";
    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);

	GenerationEnvironment = new System.Text.StringBuilder();
// Generate Rest Service Class
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the T4\Model.tt template.
//
//     Changes to this file will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//
// THIS WORK IS LICENSED UNDER A CREATIVE COMMONS ATTRIBUTION-NONCOMMERCIAL-
// SHAREALIKE 3.0 UNPORTED LICENSE:
// http://creativecommons.org/licenses/by-nc-sa/3.0/
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.Text;

namespace RockWeb.WCF
{
    [AspNetCompatibilityRequirements(RequirementsMode=AspNetCompatibilityRequirementsMode.Allowed)]
    public class RestService : IRestService
    {
<#
		foreach ( KeyValuePair<string, string> entity in entities )
		{
			string entityVar = entity.Value.Substring(0,1).ToLower() + entity.Value.Substring(1);
			string serviceNamespace = entity.Key.Replace("Models", "Services");

#>
		#region <#= entity.Value #>
		
        public <#= entity.Key #> Get<#= entity.Value #>Json( string id )
        {
            return Get<#= entity.Value #>( id );
        }

        public <#= entity.Key #> Get<#= entity.Value #>Xml( string id )
        {
            return Get<#= entity.Value #>( id );
        }

        private <#= entity.Key #> Get<#= entity.Value #>( string id )
        {
            var currentUser = System.Web.Security.Membership.GetUser();
            if ( currentUser == null )
                throw new FaultException( "Must be logged in" );

            using (Rock.Helpers.UnitOfWorkScope uow = new Rock.Helpers.UnitOfWorkScope())
            {
                uow.objectContext.Configuration.ProxyCreationEnabled = false;
                <#= serviceNamespace #>Service <#= entityVar #>Service = new <#= serviceNamespace #>Service();
                <#= entity.Key #> <#= entityVar #> = <#= entityVar #>Service.Get<#= entity.Value #>( int.Parse( id ) );
                if ( <#= entityVar #>.Authorized( "View", currentUser ) )
                    return <#= entityVar #>;
                else
                    throw new FaultException( "Unauthorized" );
            }
        }
		
        public void Update<#= entity.Value #>( string id, <#= entity.Key #> <#= entityVar #> )
        {
            var currentUser = System.Web.Security.Membership.GetUser();
            if ( currentUser == null )
                throw new FaultException( "Must be logged in" );

            using ( Rock.Helpers.UnitOfWorkScope uow = new Rock.Helpers.UnitOfWorkScope() )
            {
                uow.objectContext.Configuration.ProxyCreationEnabled = false;

                <#= serviceNamespace #>Service <#= entityVar #>Service = new <#= serviceNamespace #>Service();
                <#= entity.Key #> existing<#= entity.Value #> = <#= entityVar #>Service.Get<#= entity.Value #>( int.Parse( id ) );
                if ( existing<#= entity.Value #>.Authorized( "Edit", currentUser ) )
                {
                    uow.objectContext.Entry(existing<#= entity.Value #>).CurrentValues.SetValues(<#= entityVar #>);
                    <#= entityVar #>Service.Save( existing<#= entity.Value #>, ( int )currentUser.ProviderUserKey );
                }
                else
                    throw new FaultException( "Unauthorized" );
            }
        }

        public void Create<#= entity.Value #>( <#= entity.Key #> <#= entityVar #> )
        {
            var currentUser = System.Web.Security.Membership.GetUser();
            if ( currentUser == null )
                throw new FaultException( "Must be logged in" );

            using ( Rock.Helpers.UnitOfWorkScope uow = new Rock.Helpers.UnitOfWorkScope() )
            {
                uow.objectContext.Configuration.ProxyCreationEnabled = false;

                <#= serviceNamespace #>Service <#= entityVar #>Service = new <#= serviceNamespace #>Service();
                <#= entityVar #>Service.Attach<#= entity.Value #>( <#= entityVar #> );
                <#= entityVar #>Service.Save( <#= entityVar #>, ( int )currentUser.ProviderUserKey );
            }
        }

        public void Delete<#= entity.Value #>( string id )
        {
            var currentUser = System.Web.Security.Membership.GetUser();
            if ( currentUser == null )
                throw new FaultException( "Must be logged in" );

            using ( Rock.Helpers.UnitOfWorkScope uow = new Rock.Helpers.UnitOfWorkScope() )
            {
                uow.objectContext.Configuration.ProxyCreationEnabled = false;

                <#= serviceNamespace #>Service <#= entityVar #>Service = new <#= serviceNamespace #>Service();
                <#= entity.Key #> <#= entity.Value #> = <#= entityVar #>Service.Get<#= entity.Value #>( int.Parse( id ) );
                if ( <#= entity.Value #>.Authorized( "Edit", currentUser ) )
                {
                    <#= entityVar #>Service.Delete<#= entity.Value #>( <#= entity.Value #> );
                }
                else
                    throw new FaultException( "Unauthorized" );
            }
        }

		#endregion
		
<#
		}
#>
    }
}
<#
	// Write the Rest Service Class
    relativeOutputFilePath = @"..\..\..\RockWeb\App_Code\RestService.svc.cs";
    TemplateHelper.WriteTemplateOutputToFile(relativeOutputFilePath, Host, GenerationEnvironment);

	GenerationEnvironment = new System.Text.StringBuilder();
#>


<#+
// Class for template generation helper methods
public class TemplateHelper
{
	// Helper method to write current template contents to a file
    public static void WriteTemplateOutputToFile(
        string relativeOutputFilePath,
        Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost Host,
        System.Text.StringBuilder GenerationEnvironment)
    {
        string outputPath = System.IO.Path.GetDirectoryName(Host.TemplateFile);
		string outputFilePath = outputPath + relativeOutputFilePath;
		System.IO.FileInfo file = new System.IO.FileInfo(outputFilePath);
		if (!file.Directory.Exists)
			file.Directory.Create();
        System.IO.File.WriteAllText(outputFilePath, GenerationEnvironment.ToString());
    }
	
	// Convert SQL datatypes to C# datatype
	public static string ConvertDataType(Column column)
	{
		string nullModifier = column.Nullable ? "?" : "";

		switch (column.DataType.ToString())
		{
			case "int" : return "int" + nullModifier;
			case "bit" : return "bool" + nullModifier;
			case "varbinary"	: return "byte[]" + nullModifier;
			case "varchar": return "string";
			case "nvarchar": return "string";
			case "uniqueidentifier": return "Guid" + nullModifier;	
			case "datetime": return "DateTime" + nullModifier;
			case "char" : return "string";
			case "text" : return "string";
			case "ntext" : return "string";
			default: return column.DataType.ToString();
		}
	}
	
	// Handle Null comparison 
	public static string WhereClause(Column column)
	{
		string columnName = column.Name.Substring(0,1).ToLower() + column.Name.Substring(1);
		
		StringBuilder sb = new StringBuilder();
		sb.AppendFormat("t.{0} == {1}", column.Name, columnName);
		if (column.Nullable)
		{
			sb.Insert(0, "( ");
			sb.AppendFormat(" || ( {1} == null && t.{0} == null ) )", column.Name, columnName);
		}
		return sb.ToString();
	}

	// Get namespace from table name.  Namespace will be the text prior to the first
	// uppercase letter in the table name.
	public static string Namespace(string tableName)
	{
		for (int i = 0; i < tableName.Length; i++)
			if (Char.IsUpper(tableName[i]))
			{
				if (i > 0)
					return tableName.Substring(0,1).ToUpper() + tableName.Substring(1,i-1);
				else
					return "";					
			}
			
		return "";
	}
	
	// Get entity name from table name.  Entity will be the text starting with the 
	// first uppercase letter in the table name.
	public static string Entity(string tableName)
	{
		
		for (int i = 0; i < tableName.Length; i++)
			if (Char.IsUpper(tableName[i]))
				return tableName.Substring(i);
			
		return tableName;
	}
	
	public static bool Many2Many(Table table)
	{
		return (table.Columns.Count == 2 &&
			table.Columns[0].InPrimaryKey &&
			table.Columns[1].InPrimaryKey);
	}
	
	// Reads a text file and loads each line into a dictionary
    public static Dictionary<int, string> readTextFile(
		Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost Host,
		string relativeFilePath)
    {
        Dictionary<int, string> lines = new Dictionary<int, string>();

        string templatePath = System.IO.Path.GetDirectoryName(Host.TemplateFile);
		
        FileInfo fi = new FileInfo(templatePath + relativeFilePath);
        if (fi.Exists)
        {
            using (StreamReader sr = new StreamReader(fi.FullName))
            {
                int lineNum = 0;
                String line;
                while ((line = sr.ReadLine()) != null)
                    lines.Add(lineNum++, line.Trim());
            }
        }

        return lines;
    }

	// Finds a matching line and returns each previous line that starts with "[" (attributes)
    public static List<string> getAttributes(Dictionary<int, string> lines, string searchLine)
    {
        List<string> attributes = new List<string>();

        foreach (KeyValuePair<int, string> kvp in lines)
        {
            if (kvp.Value == searchLine)
            {
                int i = kvp.Key - 1;
                while (i >= 0 && lines[i].StartsWith("["))
                {
                    attributes.Add(lines[i]);
                    i--;
                }

                break;
            }
        }

        attributes.Reverse();

        return attributes;
    }

}

#>
